# 地点最佳评论功能需求文档

> 文档版本: v1.0
> 创建时间: 2026-02-18
> 创建者: momo 👑

---

## 1. 背景与目标

### 1.1 问题背景

在同一地点（经纬度）范围内，用户可能会发布多个帖子/打卡。这导致：
- 内容互相遮挡，信息过载
- 用户难以快速获取该地点的核心评价
- 优质评论可能被淹没在帖子下方

### 1.2 目标

为用户提供**该地点最值得看的评价**，提升信息获取效率。

---

## 2. 核心概念

### 2.1 定义

| 术语 | 定义 |
|------|------|
| 地点 | 基于经纬度坐标的地理位置，允许一定的误差范围 |
| 帖子 | 用户在某个地点发布的内容（打卡/分享等） |
| 评论 | 对帖子进行回复的内容 |
| 评价 | 帖子和评论的统称，都代表用户对该地点的看法 |
| 最佳评论 | 在同一地点范围内，点赞数最高的评价内容 |

### 2.2 核心理念

> **帖子本身就是评价的一种形式，评论也可能是更优质的评价。用户只关心"这地方怎么样"，用点赞数来决定哪个声音最有价值。**

---

## 3. 功能逻辑

### 3.1 PK机制

```
┌─────────────────────────────────────────────────────────┐
│              同一经纬度范围内（±容差）                      │
│                                                         │
│   帖子A (点赞: 50)                                       │
│   └── 评论1 (点赞: 80)  ◄── 评论中点赞最高                │
│   └── 评论2 (点赞: 30)                                   │
│                                                         │
│   帖子B (点赞: 60)                                       │
│   └── 评论3 (点赞: 45)                                   │
│                                                         │
├─────────────────────────────────────────────────────────┤
│   PK结果: 评论1 (80赞) > 帖子B (60赞) > 帖子A (50赞)       │
│   最佳评论: 评论1 🏆                                      │
└─────────────────────────────────────────────────────────┘
```

### 3.2 判定规则

**步骤1：聚合内容**
- 获取同一经纬度范围内的所有帖子
- 获取这些帖子下的所有评论

**步骤2：筛选候选**
- 每个帖子取其点赞数作为该帖子的"评价分数"
- 每个帖子下取点赞最高的评论，作为该评论的"评价分数"

**步骤3：PK比较**
- 将所有帖子和最高赞评论放在一起比较
- 点赞数最高的内容 → **最佳评论**

**步骤4：展示**
- 用户在该地点只看到最佳评论
- 其他内容折叠或作为"查看更多"展示

### 3.3 边界情况

| 场景 | 处理方式 |
|------|----------|
| 帖子点赞 = 最高评论点赞 | 优先展示帖子（发帖者优先） |
| 无评论 | 最佳评论 = 点赞最高的帖子 |
| 无帖子 | 无内容展示 |
| 点赞数均为0 | 按时间倒序，展示最新帖子 |

---

## 4. 技术方案

### 4.1 经纬度聚合

```python
# 伪代码示例
def get_nearby_posts(lat, lng, radius_meters=100):
    """
    获取指定经纬度范围内的所有帖子
    radius_meters: 允许的误差范围，默认100米
    """
    # 使用地理索引查询（如 MongoDB geoNear, MySQL spatial index）
    pass
```

### 4.2 最佳评论计算

```python
def get_best_comment(lat, lng, radius=100):
    """
    获取某地点的最佳评论
    返回: (content, like_count, source_type, source_id)
    """
    # 1. 获取范围内所有帖子
    posts = get_nearby_posts(lat, lng, radius)
    
    candidates = []
    
    for post in posts:
        # 帖子本身作为候选
        candidates.append({
            'content': post.content,
            'like_count': post.like_count,
            'source_type': 'post',
            'source_id': post.id
        })
        
        # 获取该帖子下点赞最高的评论
        top_comment = get_top_comment(post.id)
        if top_comment:
            candidates.append({
                'content': top_comment.content,
                'like_count': top_comment.like_count,
                'source_type': 'comment',
                'source_id': top_comment.id,
                'parent_post_id': post.id
            })
    
    # 按点赞数排序，取最高
    if not candidates:
        return None
    
    candidates.sort(key=lambda x: x['like_count'], reverse=True)
    return candidates[0]
```

### 4.3 数据结构

```javascript
// 最佳评论返回格式
{
  "best_comment": {
    "content": "这家店超好吃！推荐红烧肉",
    "like_count": 128,
    "source_type": "comment",  // "post" 或 "comment"
    "source_id": "comment_123",
    "parent_post_id": "post_456",  // 仅当source_type为comment时有值
    "location": {
      "lat": 31.2304,
      "lng": 121.4737
    },
    "author": {
      "id": "user_789",
      "name": "美食达人小王",
      "avatar": "https://..."
    }
  },
  "total_candidates": 5,  // 参与PK的内容总数
  "updated_at": "2026-02-18T12:00:00Z"
}
```

---

## 5. 扩展考虑

### 5.1 时间衰减（可选）

旧内容的点赞数可以按时间衰减，避免过时信息长期霸榜：

```
有效点赞数 = 原始点赞数 × e^(-λ × 天数)
```

### 5.2 内容质量过滤（可选）

- 过滤违规内容
- 过滤字数过短的内容（如"好"、"赞"）
- 过滤图片/视频内容与纯文字内容的差异

### 5.3 缓存策略

- 最佳评论结果可缓存（如5分钟）
- 当有新点赞时触发重新计算
- 热门地点可预计算

---

## 6. 验收标准

| 场景 | 预期结果 |
|------|----------|
| 同一地点有多个帖子 | 展示点赞最高的帖子或评论 |
| 评论点赞高于帖子 | 展示该评论为最佳评论 |
| 修改点赞数 | 最佳评论实时/准实时更新 |
| 无任何内容 | 不展示或展示占位文案 |
| 经纬度边界 | 正确聚合范围内的内容 |

---

## 7. 总结

**一句话需求：**
> 在同一地点范围内，将帖子和评论统一视为评价，通过点赞数PK选出最佳评论展示给用户。

**核心价值：**
- 用户只看最有价值的信息
- 优质评论不会被淹没
- 内容不互相遮挡

---

*文档由 momo 创建并维护 👑*
